{"mappings":"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","sources":["server.js","lib/ClientManager.js","lib/Client.js","lib/TunnelAgent.js"],"sourcesContent":["import log from 'book';\nimport Koa from 'koa';\nimport tldjs from 'tldjs';\nimport Debug from 'debug';\nimport http from 'http';\nimport { hri } from 'human-readable-ids';\nimport Router from 'koa-router';\n\nimport ClientManager from './lib/ClientManager';\n\nconst debug = Debug('localtunnel:server');\n\nexport default function(opt) {\n    opt = opt || {};\n\n    const validHosts = (opt.domain) ? [opt.domain] : undefined;\n    const myTldjs = tldjs.fromUserSettings({ validHosts });\n    const landingPage = opt.landing || 'https://localtunnel.github.io/www/';\n\n    function GetClientIdFromHostname(hostname) {\n        return myTldjs.getSubdomain(hostname);\n    }\n\n    const manager = new ClientManager(opt);\n\n    const schema = opt.secure ? 'https' : 'http';\n\n    const app = new Koa();\n    const router = new Router();\n\n    router.get('/api/status', async (ctx, next) => {\n        const stats = manager.stats;\n        ctx.body = {\n            tunnels: stats.tunnels,\n            mem: process.memoryUsage(),\n        };\n    });\n\n    router.get('/api/tunnels/:id/status', async (ctx, next) => {\n        const clientId = ctx.params.id;\n        const client = manager.getClient(clientId);\n        if (!client) {\n            ctx.throw(404);\n            return;\n        }\n\n        const stats = client.stats();\n        ctx.body = {\n            connected_sockets: stats.connectedSockets,\n        };\n    });\n\n    app.use(router.routes());\n    app.use(router.allowedMethods());\n\n    // root endpoint\n    app.use(async (ctx, next) => {\n        const path = ctx.request.path;\n\n        // skip anything not on the root path\n        if (path !== '/') {\n            await next();\n            return;\n        }\n\n        const isNewClientRequest = ctx.query['new'] !== undefined;\n        if (isNewClientRequest) {\n            const reqId = hri.random();\n            debug('making new client with id %s', reqId);\n            const info = await manager.newClient(reqId);\n\n            const url = schema + '://' + info.id + '.' + ctx.request.host;\n            info.url = url;\n            if (opt.ip) {\n               debug('IP ASSIGNED %s', info.ip)\n                info.ip = opt.ip;\n            } else {\n               debug('NO IP ASSIGNED %O', opt)\n            }\n            ctx.body = info;\n            return;\n        }\n\n        // no new client request, send to landing page\n        ctx.redirect(landingPage);\n    });\n\n    // anything after the / path is a request for a specific client name\n    // This is a backwards compat feature\n    app.use(async (ctx, next) => {\n       debug('KOA APP REQUEST HAPPENING %s', ctx.request.path)\n        const parts = ctx.request.path.split('/');\n\n        // any request with several layers of paths is not allowed\n        // rejects /foo/bar\n        // allow /foo\n        if (parts.length !== 2) {\n           debug('SKIPPING %O', parts)\n            await next();\n            return;\n        }\n\n        const reqId = parts[1];\n       debug('REQ ID', reqId)\n        // limit requested hostnames to 63 characters\n        if (! /^(?:[a-z0-9][a-z0-9\\-]{4,63}[a-z0-9]|[a-z0-9]{4,63})$/.test(reqId)) {\n            const msg = 'Invalid subdomain. Subdomains must be lowercase and between 4 and 63 alphanumeric characters.';\n            ctx.status = 403;\n            ctx.body = {\n                message: msg,\n            };\n            return;\n        }\n\n        debug('making new client with id %s', reqId);\n        const info = await manager.newClient(reqId);\n       debug('MADE NEW CLIENT %O', {info, host: ctx.request.host})\n        const url = schema + '://' + info.id + '.' + ctx.request.host;\n        info.url = url;\n        ctx.body = info;\n        return;\n    });\n\n    if (opt.server) {\n       debug('USING PROVIDED SERVER %O', opt)\n    } else {\n       debug('CREATING DEFAULT HTTP SERVER')\n    }\n    const server = opt.server || http.createServer();\n\n    const appCallback = app.callback();\n\n    server.on('request', (req, res) => {\n        debug('SERVER REQUEST %O', req.headers)\n        // without a hostname, we won't know who the request is for\n        const hostname = req.headers.host;\n        if (!hostname) {\n            res.statusCode = 400;\n            res.end('Host header is required');\n            return;\n        }\n\n        const clientId = GetClientIdFromHostname(hostname);\n        if (!clientId) {\n           debug('NO CLIENT ID FROM HOSTNAME? %O', {hostname, clientId})\n            appCallback(req, res);\n            return;\n        }\n\n        const client = manager.getClient(clientId);\n        if (!client) {\n           debug('NO CLIENT %O', {clientId, client, manager})\n            res.statusCode = 404;\n            res.end('404 NO CLIENT YO');\n            return;\n        }\n\n        client.handleRequest(req, res);\n    });\n\n    server.on('upgrade', (req, socket, head) => {\n        const hostname = req.headers.host;\n        if (!hostname) {\n            debug('DESTROYING SOCKET - MISSING HOSTNAME %O', req.headers)\n            socket.destroy();\n            return;\n        }\n\n        const clientId = GetClientIdFromHostname(hostname);\n        if (!clientId) {\n            debug('DESTROYING SOCKET - MISSING CLIENT ID %s', clientId)\n            socket.destroy();\n            return;\n        }\n\n        const client = manager.getClient(clientId);\n        if (!client) {\n            debug('DESTROYING SOCKET - MISSING CLIENT %O', client)\n            socket.destroy();\n            return;\n        }\n        debug('UPGRADING CLIENT?')\n        client.handleUpgrade(req, socket);\n    });\n\n    return server;\n};\n","import { hri } from 'human-readable-ids';\nimport Debug from 'debug';\n\nimport Client from './Client';\nimport TunnelAgent from './TunnelAgent';\n\n// Manage sets of clients\n//\n// A client is a \"user session\" established to service a remote localtunnel client\nclass ClientManager {\n    constructor(opt) {\n        this.opt = opt || {};\n\n        // id -> client instance\n        this.clients = new Map();\n\n        // statistics\n        this.stats = {\n            tunnels: 0\n        };\n\n        this.debug = Debug('lt:ClientManager');\n\n        // This is totally wrong :facepalm: this needs to be per-client...\n        this.graceTimeout = null;\n    }\n\n    // create a new tunnel with `id`\n    // if the id is already used, a random id is assigned\n    // if the tunnel could not be created, throws an error\n    async newClient(id) {\n        const clients = this.clients;\n        const stats = this.stats;\n\n        // can't ask for id already is use\n        if (clients[id]) {\n            id = hri.random();\n        }\n\n        const maxSockets = this.opt.max_tcp_sockets;\n        const agent = new TunnelAgent({\n            clientId: id,\n            maxSockets: 10,\n        });\n\n        const client = new Client({\n            id,\n            agent,\n        });\n\n        // add to clients map immediately\n        // avoiding races with other clients requesting same id\n        clients[id] = client;\n\n        client.once('close', () => {\n            this.removeClient(id);\n        });\n\n        // try/catch used here to remove client id\n        try {\n            const info = await agent.listen();\n            ++stats.tunnels;\n            return {\n                id: id,\n                port: info.port,\n                max_conn_count: maxSockets,\n            };\n        }\n        catch (err) {\n            this.removeClient(id);\n            // rethrow error for upstream to handle\n            throw err;\n        }\n    }\n\n    removeClient(id) {\n        this.debug('removing client: %s', id);\n        const client = this.clients[id];\n        if (!client) {\n            return;\n        }\n        --this.stats.tunnels;\n        delete this.clients[id];\n        client.close();\n    }\n\n    hasClient(id) {\n        return !!this.clients[id];\n    }\n\n    getClient(id) {\n        return this.clients[id];\n    }\n}\n\nexport default ClientManager;\n","import http from 'http';\nimport Debug from 'debug';\nimport pump from 'pump';\nimport EventEmitter from 'events';\n\n// A client encapsulates req/res handling using an agent\n//\n// If an agent is destroyed, the request handling will error\n// The caller is responsible for handling a failed request\nclass Client extends EventEmitter {\n    constructor(options) {\n        super();\n\n        const agent = this.agent = options.agent;\n        const id = this.id = options.id;\n\n        this.debug = Debug(`lt:Client[${this.id}]`);\n\n        // client is given a grace period in which they can connect before they are _removed_\n        this.graceTimeout = setTimeout(() => {\n            this.close();\n        }, 1000).unref();\n\n        agent.on('online', () => {\n            this.debug('client online %s', id);\n            clearTimeout(this.graceTimeout);\n        });\n\n        agent.on('offline', () => {\n            this.debug('client offline %s', id);\n\n            // if there was a previous timeout set, we don't want to double trigger\n            clearTimeout(this.graceTimeout);\n\n            // client is given a grace period in which they can re-connect before they are _removed_\n            this.graceTimeout = setTimeout(() => {\n                this.close();\n            }, 1000).unref();\n        });\n\n        // TODO(roman): an agent error removes the client, the user needs to re-connect?\n        // how does a user realize they need to re-connect vs some random client being assigned same port?\n        agent.once('error', (err) => {\n            this.debug('AGENT ERROR %s', err)\n            this.close();\n        });\n    }\n\n    stats() {\n        return this.agent.stats();\n    }\n\n    close() {\n        clearTimeout(this.graceTimeout);\n        this.agent.destroy();\n        this.emit('close');\n    }\n\n    handleRequest(req, res) {\n        this.debug('> %s', req.url);\n        const opt = {\n            path: req.url,\n            agent: this.agent,\n            method: req.method,\n            headers: req.headers\n        };\n\n        const clientReq = http.request(opt, (clientRes) => {\n            this.debug('< %s', req.url);\n            // write response code and headers\n            res.writeHead(clientRes.statusCode, clientRes.headers);\n\n            // using pump is deliberate - see the pump docs for why\n            pump(clientRes, res);\n        });\n\n        // this can happen when underlying agent produces an error\n        // in our case we 504 gateway error this?\n        // if we have already sent headers?\n        clientReq.once('error', (err) => {\n            // TODO(roman): if headers not sent - respond with gateway unavailable\n        });\n\n        // using pump is deliberate - see the pump docs for why\n        pump(req, clientReq);\n    }\n\n    handleUpgrade(req, socket) {\n        this.debug('> [up] %s', req.url);\n        socket.once('error', (err) => {\n            // These client side errors can happen if the client dies while we are reading\n            // We don't need to surface these in our logs.\n            if (err.code == 'ECONNRESET' || err.code == 'ETIMEDOUT') {\n                return;\n            }\n            console.error(err);\n        });\n\n        this.agent.createConnection({}, (err, conn) => {\n            this.debug('< [up] %s', req.url);\n            // any errors getting a connection mean we cannot service this request\n            if (err) {\n                socket.end();\n                return;\n            }\n\n            // socket met have disconnected while we waiting for a socket\n            if (!socket.readable || !socket.writable) {\n                conn.destroy();\n                socket.end();\n                return;\n            }\n\n            // websocket requests are special in that we simply re-create the header info\n            // then directly pipe the socket data\n            // avoids having to rebuild the request and handle upgrades via the http client\n            const arr = [`${req.method} ${req.url} HTTP/${req.httpVersion}`];\n            for (let i=0 ; i < (req.rawHeaders.length-1) ; i+=2) {\n                arr.push(`${req.rawHeaders[i]}: ${req.rawHeaders[i+1]}`);\n            }\n\n            arr.push('');\n            arr.push('');\n\n            // using pump is deliberate - see the pump docs for why\n            pump(conn, socket);\n            pump(socket, conn);\n            conn.write(arr.join('\\r\\n'));\n        });\n    }\n}\n\nexport default Client;","import { Agent } from 'http';\nimport net from 'net';\nimport assert from 'assert';\nimport log from 'book';\nimport Debug from 'debug';\n\nconst DEFAULT_MAX_SOCKETS = 10;\n\n// Implements an http.Agent interface to a pool of tunnel sockets\n// A tunnel socket is a connection _from_ a client that will\n// service http requests. This agent is usable wherever one can use an http.Agent\nclass TunnelAgent extends Agent {\n    constructor(options = {}) {\n        super({\n            keepAlive: true,\n            // only allow keepalive to hold on to one socket\n            // this prevents it from holding on to all the sockets so they can be used for upgrades\n            maxFreeSockets: 1,\n        });\n\n        // sockets we can hand out via createConnection\n        this.availableSockets = [];\n\n        // when a createConnection cannot return a socket, it goes into a queue\n        // once a socket is available it is handed out to the next callback\n        this.waitingCreateConn = [];\n\n        this.debug = Debug(`lt:TunnelAgent[${options.clientId}]`);\n\n        // track maximum allowed sockets\n        this.connectedSockets = 0;\n        this.maxTcpSockets = options.maxTcpSockets || DEFAULT_MAX_SOCKETS;\n\n        // new tcp server to service requests for this client\n        this.server = net.createServer();\n\n        // flag to avoid double starts\n        this.started = false;\n        this.closed = false;\n    }\n\n    stats() {\n        return {\n            connectedSockets: this.connectedSockets,\n        };\n    }\n\n    listen() {\n        const server = this.server;\n        if (this.started) {\n            throw new Error('already started');\n        }\n        this.started = true;\n\n        server.on('close', this._onClose.bind(this));\n        server.on('connection', this._onConnection.bind(this));\n        server.on('error', (err) => {\n            // These errors happen from killed connections, we don't worry about them\n            if (err.code == 'ECONNRESET' || err.code == 'ETIMEDOUT') {\n                return;\n            }\n            log.error(err);\n        });\n\n        return new Promise((resolve) => {\n            server.listen(() => {\n                const port = server.address().port;\n                this.debug('tcp server listening on port: %d', port);\n\n                resolve({\n                    // port for lt client tcp connections\n                    port: port,\n                });\n            });\n        });\n    }\n\n    _onClose() {\n        this.closed = true;\n        this.debug('closed tcp socket');\n        // flush any waiting connections\n        for (const conn of this.waitingCreateConn) {\n            conn(new Error('closed'), null);\n        }\n        this.waitingCreateConn = [];\n        this.emit('end');\n    }\n\n    // new socket connection from client for tunneling requests to client\n    _onConnection(socket) {\n        // no more socket connections allowed\n        if (this.connectedSockets >= this.maxTcpSockets) {\n            this.debug('no more sockets allowed');\n            socket.destroy();\n            return false;\n        }\n\n        socket.once('close', (hadError) => {\n            this.debug('closed socket (error: %s)', hadError);\n            this.connectedSockets -= 1;\n            // remove the socket from available list\n            const idx = this.availableSockets.indexOf(socket);\n            if (idx >= 0) {\n                this.availableSockets.splice(idx, 1);\n            }\n\n            this.debug('connected sockets: %s', this.connectedSockets);\n            if (this.connectedSockets <= 0) {\n                this.debug('all sockets disconnected');\n                this.emit('offline');\n            }\n        });\n\n        // close will be emitted after this\n        socket.once('error', (err) => {\n            // we do not log these errors, sessions can drop from clients for many reasons\n            // these are not actionable errors for our server\n            socket.destroy();\n        });\n\n        if (this.connectedSockets === 0) {\n            this.emit('online');\n        }\n\n        this.connectedSockets += 1;\n        this.debug('new connection from: %s:%s', socket.address().address, socket.address().port);\n\n        // if there are queued callbacks, give this socket now and don't queue into available\n        const fn = this.waitingCreateConn.shift();\n        if (fn) {\n            this.debug('giving socket to queued conn request');\n            setTimeout(() => {\n                fn(null, socket);\n            }, 0);\n            return;\n        }\n\n        // make socket available for those waiting on sockets\n        this.availableSockets.push(socket);\n    }\n\n    // fetch a socket from the available socket pool for the agent\n    // if no socket is available, queue\n    // cb(err, socket)\n    createConnection(options, cb) {\n        if (this.closed) {\n            cb(new Error('closed'));\n            return;\n        }\n\n        this.debug('create connection');\n\n        // socket is a tcp connection back to the user hosting the site\n        const sock = this.availableSockets.shift();\n\n        // no available sockets\n        // wait until we have one\n        if (!sock) {\n            this.waitingCreateConn.push(cb);\n            this.debug('waiting connected: %s', this.connectedSockets);\n            this.debug('waiting available: %s', this.availableSockets.length);\n            return;\n        }\n\n        this.debug('socket given');\n        cb(null, sock);\n    }\n\n    destroy() {\n        this.server.close();\n        super.destroy();\n    }\n}\n\nexport default TunnelAgent;\n"],"names":[],"version":3,"file":"server.js.map"}